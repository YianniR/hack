<!DOCTYPE html>
<html>
<head>
    <title>Network Graph Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        #graph {
            width: 100%;
            height: 90vh;
            border: 1px solid #333;
            border-radius: 8px;
        }
        .node {
            cursor: pointer;
        }
        .node circle {
            stroke: #fff;
            stroke-width: 2px;
            transition: all 0.3s ease;
        }
        .node:hover circle {
            stroke: #58a6ff;
            stroke-width: 3px;
            filter: brightness(1.2);
        }
        .node text {
            font-size: 10px;
            fill: #fff;
        }
        .link {
            stroke: #666;
            stroke-opacity: 0.3;
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
        }
        .controls input {
            margin: 5px 0;
            width: 200px;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;  /* Start hidden */
            max-width: 300px;
            border: 1px solid #555;
            z-index: 1000;  /* Make sure it's above other elements */
            transition: opacity 0.2s;
        }
        .tooltip a {
            color: #58a6ff;
            text-decoration: none;
        }
        .tooltip a:hover {
            text-decoration: underline;
        }
        #error {
            position: fixed;
            bottom: 20px;
            right: 20px;
            transform: none;
            background: rgba(255, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            display: none;
            max-width: 300px;
            color: white;
            font-size: 14px;
            z-index: 1000;
        }
        #debug {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .loading {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
        }
        .grid line {
            stroke: #333;
            stroke-opacity: 0.2;
        }
        .x-axis path,
        .y-axis path,
        .x-axis line,
        .y-axis line {
            stroke: #666;
        }
        .x-axis text,
        .y-axis text {
            fill: #666;
            font-size: 10px;
        }
        .axis-label {
            fill: #888;
            font-size: 12px;
            text-anchor: middle;
        }
        .quadrants line {
            stroke: #666;
            stroke-opacity: 0.5;
            stroke-dasharray: 4,4;
        }
        .quadrants text {
            font-size: 12px;
            fill: #666;
            opacity: 0.7;
        }
        /* Add subtle quadrant backgrounds */
        .quadrant-bg {
            fill: #333;
            opacity: 0.1;
        }
        /* Add these styles for the time slider */
        .time-control {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        
        .time-control label {
            display: block;
            margin-bottom: 10px;
        }
        
        .time-display {
            text-align: center;
            margin: 5px 0;
            font-size: 14px;
            color: #888;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #444;
            outline: none;
            margin: 10px 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #58a6ff;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #79beff;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="graph"></div>
    <div id="error"></div>
    <div id="debug"></div>
    <div class="controls">
        <div>
            <label>Username Search:</label>
            <input type="text" id="search" placeholder="Enter username...">
        </div>
        <div>
            <label>X-Axis Semantic:</label>
            <input type="text" id="searchTermX" placeholder="Enter word/phrase for X-axis...">
        </div>
        <div>
            <label>Y-Axis Semantic:</label>
            <input type="text" id="searchTermY" placeholder="Enter word/phrase for Y-axis...">
        </div>
        <button id="updateSemanticLayout">Update Semantic Layout</button>
        <div class="time-control">
            <label>Time Period:</label>
            <input type="range" id="timeSlider" min="0" max="100" value="100">
            <div id="timeDisplay" class="time-display">Loading dates...</div>
        </div>
    </div>
    <div class="tooltip"></div>
    <div class="loading">Processing semantic search...</div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Debug logging function
        function log(message, data) {
            const debug = document.getElementById('debug');
            const time = new Date().toLocaleTimeString();
            debug.innerHTML += `<div>[${time}] ${message}</div>`;
            if (data) {
                debug.innerHTML += `<div style="color: #888">${JSON.stringify(data)}</div>`;
            }
            debug.scrollTop = debug.scrollHeight;
            console.log(message, data);
        }

        // Error display function
        function showError(message) {
            const error = document.getElementById('error');
            error.style.display = 'block';
            error.textContent = message;
            log('ERROR: ' + message);
        }

        let userEmbeddings = {};  // Initialize globally
        let nodes = [];          // Initialize nodes globally too
        let simulation;          // Initialize simulation globally
        let currentSimilarities = new Map();
        let profiles = {};       // Initialize profiles globally
        let node;               // For node elements 
        let link;               // For link elements
        let gridAndAxes;  // For the axes container
        let width;        // For the SVG dimensions
        let height;
        let allWeeks = [];
        let currentWeek = null;
        let weeklyData = null;  // Will store the full weekly data structure

        async function loadGraph() {
            try {
                log('Starting graph load...');
                
                // Load embeddings first
                log('Loading embeddings...');
                userEmbeddings = await loadEmbeddings();
                
                // Load profiles and store globally
                log('Loading user profiles...');
                const profileResponse = await fetch('/data/user_profiles.json');
                if (!profileResponse.ok) {
                    throw new Error(`Failed to load profiles: ${profileResponse.status}`);
                }
                profiles = await profileResponse.json();  // Assign to global variable
                log(`Loaded profiles for ${Object.keys(profiles).length} users`);
                
                log('Loading graph...');
                const response = await fetch('/network_map.graphml');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                log('Received GraphML content, first 100 chars:', text.substring(0, 100));
                
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, "text/xml");
                
                if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
                    throw new Error('XML parsing failed');
                }

                // Parse nodes
                nodes = Array.from(xmlDoc.getElementsByTagName('node')).map(node => ({
                    id: node.getAttribute('id'),
                    username: node.querySelector('[key="username"]')?.textContent || '',
                    display_name: node.querySelector('[key="display_name"]')?.textContent || '',
                    description: node.querySelector('[key="description"]')?.textContent || ''
                }));
                log('Parsed nodes:', { count: nodes.length, sample: nodes.slice(0, 2) });

                // Parse edges
                const edges = Array.from(xmlDoc.getElementsByTagName('edge')).map(edge => ({
                    source: edge.getAttribute('source'),
                    target: edge.getAttribute('target'),
                    type: 'follows'
                }));
                log('Parsed edges:', { count: edges.length, sample: edges.slice(0, 2) });

                if (nodes.length === 0) {
                    throw new Error('No nodes found in the GraphML file');
                }
                if (edges.length === 0) {
                    throw new Error('No edges found in the GraphML file');
                }

                // After loading embeddings and before creating nodes
                // Filter nodes to only include those with embeddings
                nodes = nodes.filter(node => {
                    const hasEmbedding = userEmbeddings[node.id]?.embedding;
                    if (!hasEmbedding) {
                        log(`Skipping node without embedding: @${node.username} (${node.id})`);
                    }
                    return hasEmbedding;
                });

                log(`Filtered nodes: ${nodes.length} have embeddings`);

                // Then filter edges to only include nodes with embeddings
                const nodeIds = new Set(nodes.map(n => n.id));
                const validEdges = edges.filter(edge => 
                    nodeIds.has(edge.source) && nodeIds.has(edge.target)
                );

                log('Filtered edges:', { 
                    original: edges.length, 
                    valid: validEdges.length, 
                    removed: edges.length - validEdges.length 
                });

                const width = document.getElementById('graph').clientWidth;
                const height = document.getElementById('graph').clientHeight;
                window.width = width;
                window.height = height;
                
                const svg = d3.select('#graph')
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                // Add defs for patterns
                const defs = svg.append('defs');

                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        container.attr('transform', event.transform);
                    });

                svg.call(zoom);

                const container = svg.append('g');
                gridAndAxes = container.append('g').attr('class', 'grid-and-axes');

                // Create initial grid and axes
                createGrid();
                updateAxes();

                // Create arrow marker for directed edges
                svg.append("defs").append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 20)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", "#666");

                // Update simulation to only handle collisions
                simulation = d3.forceSimulation(nodes)
                    .force("collide", d3.forceCollide().radius(25))   // Only keep collision detection
                    .force("x", null)
                    .force("y", null);

                // Update the link creation to store in global variable
                link = container.append("g")
                    .selectAll("line")
                    .data(validEdges)
                    .join("line")
                    .attr("class", "link")
                    .attr("marker-end", "url(#arrowhead)");

                // Update the node creation to store in global variable
                node = container.append("g")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "node")
                    .call(drag(simulation));

                // Replace the circle with profile picture or fallback circle
                node.each(function(d) {
                    const nodeGroup = d3.select(this);
                    const profile = profiles[d.id];
                    
                    if (profile?.avatar_url) {
                        // Create unique pattern ID for this node
                        const patternId = `avatar-${d.id}`;
                        
                        // Add pattern definition
                        defs.append('pattern')
                            .attr('id', patternId)
                            .attr('width', 1)
                            .attr('height', 1)
                            .attr('patternUnits', 'objectBoundingBox')
                            .append('image')
                            .attr('xlink:href', profile.avatar_url)
                            .attr('width', 40)  // Make image size larger
                            .attr('height', 40)
                            .attr('preserveAspectRatio', 'xMidYMid slice');
                        
                        // Add circle with pattern fill
                        nodeGroup.append('circle')
                            .attr('r', 20)  // Make nodes larger
                            .style('fill', `url(#${patternId})`)
                            .style('stroke', '#fff')
                            .style('stroke-width', '2px');
                    } else {
                        // Fallback circle for nodes without images
                        nodeGroup.append('circle')
                            .attr('r', 20)
                            .style('fill', d => getNodeColor(d))
                            .style('stroke', '#fff')
                            .style('stroke-width', '2px');
                    }
                });

                node.append("text")
                    .attr("dx", 8)
                    .attr("dy", ".35em")
                    .text(d => d.username)
                    .style("opacity", 0);

                // Update the node event handlers
                node.on("mouseover", function(event, d) {
                    // Show username text
                    d3.select(this).select("text").style("opacity", 1);
                    
                    // Show tooltip with full debug
                    log(`Mouse over: ${d.username} (${d.id})`);
                    const profile = profiles[d.id];
                    log(`Profile data:`, profile);
                    const similarity = currentSimilarities.get(d.id);
                    log(`Similarity:`, similarity);
                    
                    const tooltip = d3.select(".tooltip");
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                        
                    tooltip.html(`
                        <div style="text-align: center;">
                            <strong>@${d.username}</strong>
                            ${profile?.bio ? `<br><em>${profile.bio}</em>` : ''}
                            ${profile?.location ? `<br>üìç ${profile.location}` : ''}
                            ${profile?.website ? `<br>üîó <a href="${profile.website}" target="_blank">${profile.website}</a>` : ''}
                            ${currentSimilarities.size > 0 && similarity ? `
                                <br><br>
                                <div style="background: rgba(255,255,255,0.1); padding: 5px; border-radius: 4px;">
                                    ${searchTermX ? `"${searchTermX}": <strong>${(similarity.x * 100).toFixed(1)}%</strong><br>` : ''}
                                    ${searchTermY ? `"${searchTermY}": <strong>${(similarity.y * 100).toFixed(1)}%</strong>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px")
                    .style("display", "block");
                })
                .on("mouseout", function() {
                    // Hide username text
                    d3.select(this).select("text").style("opacity", 0);
                    
                    // Hide tooltip
                    d3.select(".tooltip")
                        .transition()
                        .duration(500)
                        .style("opacity", 0)
                        .style("display", "none");
                });

                // Search functionality
                d3.select("#search").on("input", function() {
                    const searchTerm = this.value.toLowerCase();
                    node.each(function(d) {
                        const element = d3.select(this);
                        const matches = d.username.toLowerCase().includes(searchTerm);
                        element.style("opacity", matches || !searchTerm ? 1 : 0.1);
                    });
                });

                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });

                function getNodeColor(d) {
                    return "#666";  // Default color for nodes without profile pics
                }

                function drag(simulation) {
                    function dragstarted(event) {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        event.subject.fx = event.subject.x;
                        event.subject.fy = event.subject.y;
                    }

                    function dragged(event) {
                        event.subject.fx = event.x;
                        event.subject.fy = event.y;
                    }

                    function dragended(event) {
                        if (!event.active) simulation.alphaTarget(0);
                        event.subject.fx = null;
                        event.subject.fy = null;
                    }

                    return d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended);
                }

                // Add this helper function at the top level
                function getLatestEmbedding(userData) {
                    if (!userData) return null;
                    
                    // Get all weeks sorted in descending order
                    const weeks = Object.keys(userData).sort().reverse();
                    
                    // Find first week that has an embedding
                    for (const week of weeks) {
                        if (userData[week]?.embedding) {
                            return userData[week].embedding;
                        }
                    }
                    return null;
                }

                // Add this helper function
                function getAverageEmbedding(userData) {
                    const embeddings = [];
                    for (const weekData of Object.values(userData)) {
                        if (weekData?.embedding) {
                            embeddings.push(weekData.embedding);
                        }
                    }
                    
                    if (embeddings.length === 0) return null;
                    
                    // Calculate average
                    const sum = embeddings.reduce((acc, curr) => {
                        return acc.map((val, i) => val + curr[i]);
                    }, new Array(embeddings[0].length).fill(0));
                    
                    return sum.map(val => val / embeddings.length);
                }

                // Modify loadEmbeddings to use averaged embeddings
                async function loadEmbeddings() {
                    try {
                        log('Loading embeddings...');
                        const response = await fetch('/data/user_embeddings.json');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        weeklyData = await response.json();
                        log(`Received embeddings file (${response.headers.get('content-length')} bytes)`);
                        
                        // Convert weekly data to averaged embeddings
                        const averagedEmbeddings = {};
                        for (const [userId, userData] of Object.entries(weeklyData)) {
                            const avgEmbedding = getAverageEmbedding(userData);
                            if (avgEmbedding) {
                                averagedEmbeddings[userId] = {
                                    embedding: avgEmbedding
                                };
                            }
                        }
                        
                        const userCount = Object.keys(averagedEmbeddings).length;
                        log(`Successfully parsed embeddings for ${userCount} users`);
                        
                        return averagedEmbeddings;
                    } catch (error) {
                        log('Error loading embeddings:', error);
                        throw error;
                    }
                }

                // Add this function to initialize the time slider
                function initializeTimeSlider() {
                    const slider = document.getElementById('timeSlider');
                    const display = document.getElementById('timeDisplay');
                    
                    // Set slider range
                    slider.min = 0;
                    slider.max = allWeeks.length - 1;
                    slider.value = allWeeks.length - 1;  // Start at most recent
                    
                    // Update display
                    const displayDate = new Date(currentWeek);
                    display.textContent = `Week of ${displayDate.toLocaleDateString()}`;
                    
                    // Add event listener
                    slider.addEventListener('input', (event) => {
                        const weekIndex = parseInt(event.target.value);
                        currentWeek = allWeeks[weekIndex];
                        const date = new Date(currentWeek);
                        display.textContent = `Week of ${date.toLocaleDateString()}`;
                        // We'll add the actual update logic later
                    });
                }

                // Calculate cosine similarity
                function cosineSimilarity(a, b) {
                    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
                    const normA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
                    const normB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
                    return dotProduct / (normA * normB);
                }

                // First, let's create a quadrant-based layout system
                function createQuadrantSystem(container, width, height) {
                    // Add quadrant lines
                    const quadrants = container.append('g').attr('class', 'quadrants');
                    
                    // Vertical center line
                    quadrants.append('line')
                        .attr('x1', width/2)
                        .attr('y1', 0)
                        .attr('x2', width/2)
                        .attr('y2', height)
                        .attr('stroke', '#666')
                        .attr('stroke-width', 2);
                    
                    // Horizontal center line
                    quadrants.append('line')
                        .attr('x1', 0)
                        .attr('y1', height/2)
                        .attr('x2', width)
                        .attr('y2', height/2)
                        .attr('stroke', '#666')
                        .attr('stroke-width', 2);
                    
                    // Add quadrant labels
                    const labels = [
                        { x: width * 0.25, y: height * 0.25, text: "Q2: High Y, Low X" },
                        { x: width * 0.75, y: height * 0.25, text: "Q1: High Y, High X" },
                        { x: width * 0.25, y: height * 0.75, text: "Q3: Low Y, Low X" },
                        { x: width * 0.75, y: height * 0.75, text: "Q4: Low Y, High X" }
                    ];
                    
                    quadrants.selectAll('text')
                        .data(labels)
                        .enter()
                        .append('text')
                        .attr('x', d => d.x)
                        .attr('y', d => d.y)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#666')
                        .text(d => d.text);
                }

                // First, add these helper functions for coordinate conversion
                function createCoordinateSystem() {
                    const margin = {top: 50, right: 50, bottom: 50, left: 50};
                    const graphWidth = width - margin.left - margin.right;
                    const graphHeight = height - margin.top - margin.bottom;

                    // Create scales for data-to-screen conversion
                    const xScale = d3.scaleLinear()
                        .domain([0, 1])
                        .range([margin.left, width - margin.right]);

                    const yScale = d3.scaleLinear()
                        .domain([0, 1])
                        .range([height - margin.bottom, margin.top]); // Inverted for y-axis

                    return {margin, graphWidth, graphHeight, xScale, yScale};
                }

                // Update the axes creation
                function updateAxes(searchTermX, searchTermY) {
                    if (!gridAndAxes) return;

                    // Clear previous axes
                    gridAndAxes.selectAll('*').remove();

                    const {margin, graphWidth, graphHeight, xScale, yScale} = createCoordinateSystem();

                    // Create axes
                    const xAxis = d3.axisBottom(xScale)
                        .ticks(10)
                        .tickFormat(d3.format('.1f'));
                    
                    const yAxis = d3.axisLeft(yScale)
                        .ticks(10)
                        .tickFormat(d3.format('.1f'));

                    // Add X axis
                    gridAndAxes.append('g')
                        .attr('class', 'x-axis')
                        .attr('transform', `translate(0,${height - margin.bottom})`)
                        .call(xAxis)
                        .call(g => g.selectAll('.tick line')
                            .clone()
                            .attr('y2', -(graphHeight))
                            .attr('stroke-opacity', 0.1));

                    // Add Y axis
                    gridAndAxes.append('g')
                        .attr('class', 'y-axis')
                        .attr('transform', `translate(${margin.left},0)`)
                        .call(yAxis)
                        .call(g => g.selectAll('.tick line')
                            .clone()
                            .attr('x2', graphWidth)
                            .attr('stroke-opacity', 0.1));

                    // Add axis labels with better positioning
                    if (searchTermX) {
                        gridAndAxes.append('text')
                            .attr('class', 'axis-label')
                            .attr('x', width / 2)
                            .attr('y', height - margin.bottom / 3)
                            .attr('text-anchor', 'middle')
                            .attr('fill', '#666')
                            .style('font-size', '14px')
                            .text(searchTermX);
                    }

                    if (searchTermY) {
                        gridAndAxes.append('text')
                            .attr('class', 'axis-label')
                            .attr('transform', `rotate(-90) translate(${-height/2}, ${margin.left/3})`)
                            .attr('text-anchor', 'middle')
                            .attr('fill', '#666')
                            .style('font-size', '14px')
                            .text(searchTermY);
                    }

                    // Style axes
                    gridAndAxes.selectAll('.tick line')
                        .attr('stroke', '#666');
                    
                    gridAndAxes.selectAll('.tick text')
                        .attr('fill', '#666')
                        .style('font-size', '10px');
                    
                    gridAndAxes.selectAll('path.domain')
                        .attr('stroke', '#666')
                        .attr('stroke-width', 1.5);
                }

                // Update the node positioning to use the new coordinate system
                function positionNodes(nodes, similarities, width, height) {
                    const {margin, xScale, yScale} = createCoordinateSystem();
                    
                    // Find min/max values for normalization
                    let minX = 1, maxX = -1, minY = 1, maxY = -1;
                    similarities.forEach(sim => {
                        minX = Math.min(minX, sim.x);
                        maxX = Math.max(maxX, sim.x);
                        minY = Math.min(minY, sim.y);
                        maxY = Math.max(maxY, sim.y);
                    });

                    nodes.forEach(node => {
                        const sim = similarities.get(node.id);
                        if (!sim) return;
                        
                        // Normalize values to 0-1 range
                        const normalizedX = (sim.x - minX) / (maxX - minX);
                        const normalizedY = (sim.y - minY) / (maxY - minY);
                        
                        // Use scales to convert to screen coordinates
                        node.x = xScale(normalizedX);
                        node.y = yScale(normalizedY);
                        
                        // Add small random jitter to prevent overlaps
                        const jitter = 3;
                        node.x += (Math.random() - 0.5) * jitter;
                        node.y += (Math.random() - 0.5) * jitter;
                        
                        // Constrain to margins
                        node.x = Math.max(margin.left, Math.min(width - margin.right, node.x));
                        node.y = Math.max(margin.top, Math.min(height - margin.bottom, node.y));
                    });
                }

                // Update the semantic search function
                async function addSemanticForce() {
                    const loading = document.querySelector('.loading');
                    loading.style.display = 'block';
                    
                    try {
                        const searchTermX = document.getElementById('searchTermX').value;
                        const searchTermY = document.getElementById('searchTermY').value;
                        
                        if (!searchTermX || !searchTermY) {
                            showError("Please enter both X and Y axis terms");
                            return;
                        }
                        
                        // Get embeddings and calculate similarities
                        const similarities = new Map();
                        const [embeddingX, embeddingY] = await Promise.all([
                            getEmbedding(searchTermX),
                            getEmbedding(searchTermY)
                        ]);
                        
                        // Calculate similarities for all nodes
                        nodes.forEach(node => {
                            const nodeEmbedding = userEmbeddings[node.id].embedding;
                            similarities.set(node.id, {
                                x: cosineSimilarity(embeddingX, nodeEmbedding),
                                y: cosineSimilarity(embeddingY, nodeEmbedding)
                            });
                        });
                        
                        // Store similarities and position nodes
                        currentSimilarities = similarities;
                        positionNodes(nodes, similarities, width, height);
                        
                        // Update visualization
                        updateVisualization();
                        
                        // Log quadrant counts
                        logQuadrantStats(similarities);
                        
                    } catch (error) {
                        showError(error.message);
                    } finally {
                        loading.style.display = 'none';
                    }
                }

                // Add quadrant statistics
                function logQuadrantStats(similarities) {
                    const quadrants = {
                        "Q1 (High X, High Y)": 0,
                        "Q2 (Low X, High Y)": 0,
                        "Q3 (Low X, Low Y)": 0,
                        "Q4 (High X, Low Y)": 0
                    };
                    
                    similarities.forEach(sim => {
                        if (sim.x >= 0 && sim.y >= 0) quadrants["Q1 (High X, High Y)"]++;
                        else if (sim.x < 0 && sim.y >= 0) quadrants["Q2 (Low X, High Y)"]++;
                        else if (sim.x < 0 && sim.y < 0) quadrants["Q3 (Low X, Low Y)"]++;
                        else quadrants["Q4 (High X, Low Y)"]++;
                    });
                    
                    log("Quadrant distribution:", quadrants);
                }

                // Update tooltip to show normalized values
                function showTooltip(event, d) {
                    const profile = profiles[d.id];
                    const similarity = currentSimilarities.get(d.id);
                    const searchTermX = document.getElementById('searchTermX').value;
                    const searchTermY = document.getElementById('searchTermY').value;
                    
                    const tooltip = d3.select(".tooltip");
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                        
                    tooltip.html(`
                        <div style="text-align: center;">
                            <strong>@${d.username}</strong>
                            ${profile?.bio ? `<br><em>${profile.bio}</em>` : ''}
                            ${profile?.location ? `<br>üìç ${profile.location}` : ''}
                            ${profile?.website ? `<br>üîó <a href="${profile.website}" target="_blank">${profile.website}</a>` : ''}
                            ${currentSimilarities.size > 0 && similarity ? `
                                <br><br>
                                <div style="background: rgba(255,255,255,0.1); padding: 5px; border-radius: 4px;">
                                    ${searchTermX ? `"${searchTermX}": <strong>${(similarity.x * 100).toFixed(1)}%</strong><br>` : ''}
                                    ${searchTermY ? `"${searchTermY}": <strong>${(similarity.y * 100).toFixed(1)}%</strong>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px")
                    .style("display", "block");
                }

                // Add button handler
                document.getElementById('updateSemanticLayout').addEventListener('click', () => {
                    addSemanticForce();
                });

                // Update controls with debounce
                function debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                }

                // Move initialization here
                async function init() {
                    // Add semantic force handlers
                    const debouncedSemanticForce = debounce(addSemanticForce, 500);
                    d3.select('#searchTermX').on('input', debouncedSemanticForce);
                    d3.select('#searchTermY').on('input', debouncedSemanticForce);
                }
                
                await init();  // Wait for initialization
                log('Initialization complete');
                
            } catch (error) {
                showError(`Failed to load graph: ${error.message}`);
                console.error('Error details:', error);
            }
        }

        // Add this function before addSemanticForce
        async function getEmbedding(text) {
            const response = await fetch(`/get_embedding?text=${encodeURIComponent(text)}`);
            if (!response.ok) {
                throw new Error(`Failed to get embedding: ${response.status}`);
            }
            const data = await response.json();
            return data.embedding;
        }

        // Move updateVisualization to global scope
        function updateVisualization() {
            if (!node || !link) return; // Guard against undefined elements
            
            // Update node positions
            node.attr("transform", d => `translate(${d.x},${d.y})`);
            
            // Update links
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            
            // Update axes
            const searchTermX = document.getElementById('searchTermX').value;
            const searchTermY = document.getElementById('searchTermY').value;
            updateAxes(searchTermX, searchTermY);
        }

        // Move createGrid function to global scope (outside loadGraph)
        function createGrid() {
            const gridSize = 50; // Size of grid squares
            const numLinesX = Math.floor(width / gridSize);
            const numLinesY = Math.floor(height / gridSize);
            
            // Remove old grid
            gridAndAxes.selectAll('.grid').remove();
            
            // Create grid
            const grid = gridAndAxes.append('g').attr('class', 'grid');
            
            // Vertical lines
            for (let i = 0; i <= numLinesX; i++) {
                grid.append('line')
                    .attr('x1', i * gridSize)
                    .attr('y1', 0)
                    .attr('x2', i * gridSize)
                    .attr('y2', height);
            }
            
            // Horizontal lines
            for (let i = 0; i <= numLinesY; i++) {
                grid.append('line')
                    .attr('x1', 0)
                    .attr('y1', i * gridSize)
                    .attr('x2', width)
                    .attr('y2', i * gridSize);
            }
        }

        // Start loading when page is ready
        document.addEventListener('DOMContentLoaded', loadGraph);
    </script>
</body>
</html> 